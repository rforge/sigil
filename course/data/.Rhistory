head(PassBoth2)
summary(PassBoth2$corpus)
brown2.names <- as.character(subset(brown.cats, cat %in% select.cats)$name)#
brown2.cats <- data.frame(cat=select.cats, name=factor(brown2.names, levels=brown2.names))#
Brown2$corpus <- "AmA"#
LOB2$corpus <- "BrE"#
PassBoth2 <- rbind(Brown2, LOB2)#
PassBoth2 <- transform(PassBoth2, corpus=factor(corpus), relative_frequency=100*passive/n_s)#
PassBoth2 <- merge(PassBoth2, brown2.cats, by="cat")
trellis.device(device=screen.device, color=TRUE, width=12, height=6, theme=col.whitebg())#
#
my.pars <- list(box.rectangle=list(col=c("black","red"), lwd=1, fill=c("#DDDDDD","#FFCCCC")), box.umbrella=list(col=c("black","red"),lwd=1,lty="solid"), plot.symbol=list(col="#0000AA"))#
my.panel <- function (x, y, grand.means=NULL, ...) {#
  if (! missing(grand.means)) {#
    panel.lines(c(0,1.5), 100*grand.means[1], lwd=2, col="black")#
    panel.lines(c(1.5,3), 100*grand.means[2], lwd=2, col="red")#
  }#
  panel.bwplot(x, y, ...)#
  domain.means <- aggregate(y, list(x), mean)#
  panel.points(domain.means$x, pch=19, cex=1.1, col=c("black","red"))#
}#
#
bwplot(relative_frequency ~ corpus | name, aspect=4, box.ratio=2, pch="|", data=PassBoth2, ylim=c(0,100), ylab="relative frequency of passives (%)", panel=my.panel, par.settings=my.pars)#
dev.copy2pdf(file="img/AmBrE_passive_bwplot_1.pdf", onefile=FALSE)#
#
bwplot(relative_frequency ~ corpus | name, aspect=4, box.ratio=2, pch="|", data=PassBoth2, ylim=c(0,100), ylab="relative frequency of passives (%)", panel=my.panel, grand.means=c(p2.brown,p2.lob), par.settings=my.pars)#
dev.copy2pdf(file="img/AmBrE_passive_bwplot_2.pdf", onefile=FALSE)#
#
dev.off()
brown2.names <- as.character(subset(brown.cats, cat %in% select.cats)$name)#
brown2.cats <- data.frame(cat=select.cats, name=factor(brown2.names, levels=brown2.names))#
Brown2$corpus <- "AmE"#
LOB2$corpus <- "BrE"#
PassBoth2 <- rbind(Brown2, LOB2)#
PassBoth2 <- transform(PassBoth2, corpus=factor(corpus), relative_frequency=100*passive/n_s)#
PassBoth2 <- merge(PassBoth2, brown2.cats, by="cat")#
#
trellis.device(device=screen.device, color=TRUE, width=12, height=6, theme=col.whitebg())#
#
my.pars <- list(box.rectangle=list(col=c("black","red"), lwd=1, fill=c("#DDDDDD","#FFCCCC")), box.umbrella=list(col=c("black","red"),lwd=1,lty="solid"), plot.symbol=list(col="#0000AA"))#
my.panel <- function (x, y, grand.means=NULL, ...) {#
  if (! missing(grand.means)) {#
    panel.lines(c(0,1.5), 100*grand.means[1], lwd=2, col="black")#
    panel.lines(c(1.5,3), 100*grand.means[2], lwd=2, col="red")#
  }#
  panel.bwplot(x, y, ...)#
  domain.means <- aggregate(y, list(x), mean)#
  panel.points(domain.means$x, pch=19, cex=1.1, col=c("black","red"))#
}#
#
bwplot(relative_frequency ~ corpus | name, aspect=4, box.ratio=2, pch="|", data=PassBoth2, ylim=c(0,100), ylab="relative frequency of passives (%)", panel=my.panel, par.settings=my.pars)#
dev.copy2pdf(file="img/AmBrE_passive_bwplot_1.pdf", onefile=FALSE)#
#
bwplot(relative_frequency ~ corpus | name, aspect=4, box.ratio=2, pch="|", data=PassBoth2, ylim=c(0,100), ylab="relative frequency of passives (%)", panel=my.panel, grand.means=c(p2.brown,p2.lob), par.settings=my.pars)#
dev.copy2pdf(file="img/AmBrE_passive_bwplot_2.pdf", onefile=FALSE)#
#
dev.off()
signif.code <- function (p) {#
  ifelse(p < .01, ifelse(p < .001, "***", "**"), ifelse(p < .05, "*", ifelse(p < .1, "?", "")))#
}#
test.genre <- function (cat, data=PassBoth, catinfo=brown.cats) {#
  .cat <- as.character(cat)  # so we can use local variable in subset() below#
  ## NB: as.character() avoids problems with different sets of levels if arg <cat> is part of factor#
  cat.name <- as.character(catinfo$name[catinfo$cat == .cat])#
  data.Brown <- subset(data, cat == .cat & corpus == "AmE")#
  data.LOB <- subset(data, cat == .cat & corpus == "BrE")#
  k.Brown <- sum(data.Brown$passive)  # pooled data (k = passives, n = sample size)#
  n.Brown <- sum(data.Brown$n_s)#
  k.LOB <- sum(data.LOB$passive)#
  n.LOB <- sum(data.LOB$n_s)#
  p.Brown <- k.Brown / n.Brown # MLE for respective population proportion#
  p.LOB <- k.LOB / n.LOB#
  E.sd.Brown <- sqrt(100 * p.Brown * (1 - p.Brown)) # expected s.d. (assuming 100 sentences per sample)#
  E.sd.LOB <- sqrt(100 * p.LOB * (1 - p.LOB))#
  O.sd.Brown <- sd(data.Brown$passive)  # observed s.d.#
  O.sd.LOB <- sd(data.LOB$passive)#
  randomness.Brown <- ks.test(jitter(data.Brown$passive), "pnorm", mean=mean(data.Brown$passive), sd=E.sd.Brown)$p.value#
  randomness.LOB <- ks.test(jitter(data.LOB$passive), "pnorm", mean=mean(data.LOB$passive), sd=E.sd.LOB)$p.value#
  .res <- prop.test(c(k.LOB, k.Brown), c(n.LOB, n.Brown)) # chi-squared test on pooled data#
  X2 <- .res$statistic#
  chisq.p <- .res$p.value#
  .res <- t.test( data.LOB$passive / data.LOB$n_s, data.Brown$passive / data.Brown$n_s) # t-test on individual texts#
  t <- .res$statistic#
  t.p <- .res$p.value#
  data.frame(p.Brown, p.LOB, E.sd.Brown, O.sd.Brown, KS1=signif.code(randomness.Brown), E.sd.LOB, O.sd.LOB, KS2=signif.code(randomness.LOB), X2, ChiSq=chisq.p, Sig1=signif.code(chisq.p), t, t.Test=t.p, Sig2=signif.code(t.p), row.names=cat.name)#
}#
#
all.genres2 <- do.call(rbind, lapply(brown2.cats$cat, test.genre, data=PassBoth2, catinfo=brown2.cats))#
all.genres2[, 1:2] <- round(all.genres2[, 1:2], 4)  # round different columns appropriately#
all.genres2[, c(3,4,6,7)] <- round(all.genres2[, c(3,4,6,7)], 2)#
all.genres2[, c(9,12)] <- round(all.genres2[, c(9,12)], 2)#
all.genres2[, c(10,13)] <- signif(all.genres2[, c(10,13)], 3)#
print(all.genres2)
options("width")
signif.code <- function (p) {#
  ifelse(p < .01, ifelse(p < .001, "***", "**"), ifelse(p < .05, "*", ifelse(p < .1, "?", "")))#
}#
test.genre <- function (cat, data=PassBoth, catinfo=brown.cats) {#
  .cat <- as.character(cat)  # so we can use local variable in subset() below#
  ## NB: as.character() avoids problems with different sets of levels if arg <cat> is part of factor#
  cat.name <- as.character(catinfo$name[catinfo$cat == .cat])#
  data.Brown <- subset(data, cat == .cat & corpus == "AmE")#
  data.LOB <- subset(data, cat == .cat & corpus == "BrE")#
  k.Brown <- sum(data.Brown$passive)  # pooled data (k = passives, n = sample size)#
  n.Brown <- sum(data.Brown$n_s)#
  k.LOB <- sum(data.LOB$passive)#
  n.LOB <- sum(data.LOB$n_s)#
  p.Brown <- k.Brown / n.Brown # MLE for respective population proportion#
  p.LOB <- k.LOB / n.LOB#
  E.sd.Brown <- sqrt(100 * p.Brown * (1 - p.Brown)) # expected s.d. (assuming 100 sentences per sample)#
  E.sd.LOB <- sqrt(100 * p.LOB * (1 - p.LOB))#
  O.sd.Brown <- sd(data.Brown$passive)  # observed s.d.#
  O.sd.LOB <- sd(data.LOB$passive)#
  randomness.Brown <- ks.test(jitter(data.Brown$passive), "pnorm", mean=mean(data.Brown$passive), sd=E.sd.Brown)$p.value#
  randomness.LOB <- ks.test(jitter(data.LOB$passive), "pnorm", mean=mean(data.LOB$passive), sd=E.sd.LOB)$p.value#
  .res <- prop.test(c(k.LOB, k.Brown), c(n.LOB, n.Brown)) # chi-squared test on pooled data#
  X2 <- .res$statistic#
  chisq.p <- .res$p.value#
  .res <- t.test( data.LOB$passive / data.LOB$n_s, data.Brown$passive / data.Brown$n_s) # t-test on individual texts#
  t <- .res$statistic#
  t.p <- .res$p.value#
  data.frame(p.Brown, p.LOB, E.sd.Brown, O.sd.Brown, KS1=signif.code(randomness.Brown), E.sd.LOB, O.sd.LOB, KS2=signif.code(randomness.LOB), X2, ChiSq=chisq.p, Sig1=signif.code(chisq.p), t, t.Test=t.p, Sig2=signif.code(t.p), row.names=cat.name)#
}#
#
all.genres2 <- do.call(rbind, lapply(brown2.cats$cat, test.genre, data=PassBoth2, catinfo=brown2.cats))#
all.genres2[, 1:2] <- round(all.genres2[, 1:2], 4)  # round different columns appropriately#
all.genres2[, c(3,4,6,7)] <- round(all.genres2[, c(3,4,6,7)], 2)#
all.genres2[, c(9,12)] <- round(all.genres2[, c(9,12)], 2)#
all.genres2[, c(10,13)] <- signif(all.genres2[, c(10,13)], 3)#
print(all.genres2)
options("width")
f\
options("width")
options(width=120)
1:100
options(width=130)
1:100
options(width=150)
1:100
options(width=125)
1:100
all.genres2 <- do.call(rbind, lapply(brown2.cats$cat, test.genre, data=PassBoth2, catinfo=brown2.cats))#
all.genres2[, 1:2] <- round(all.genres2[, 1:2], 4)  # round different columns appropriately#
all.genres2[, c(3,4,6,7)] <- round(all.genres2[, c(3,4,6,7)], 2)#
all.genres2[, c(9,12)] <- round(all.genres2[, c(9,12)], 2)#
all.genres2[, c(10,13)] <- signif(all.genres2[, c(10,13)], 3)#
print(all.genres2)
screen.device(width=8, height=8, bg="white")#
par(cex=1.3, mar=c(4,4,2,1)+.5, oma=c(0,0,0,0), mfrow=c(2,2))
Predictors <- aggregate(data.frame(observed_mean=PassBoth$relative_frequency), list(corpus=PassBoth$corpus, name=PassBoth$name), mean)
LM <- lm(relative_frequency ~ corpus + name, data=PassBoth)#
print(anova(LM))  # AmE/BrE has more significant effect once register variation is taken into account#
print(summary(LM)) # effect size and effects of individual registers (model estimates)#
print(confint(LM)) # 95% confidence interval for effect size of AmE/BrE#
plot(LM) # model diagnostics (residuals increase with relative frequency!)
Predictors2 <- aggregate(data.frame(observed_mean=PassBoth2$relative_frequency), list(corpus=PassBoth2$corpus, name=PassBoth2$name), mean)
LM <- lm(relative_frequency ~ corpus + name, data=PassBoth2)
print(anova(LM))  # AmE/BrE has significant effect once register variation is taken into account
print(summary(LM)) # effect size and effects of individual registers (model estimates)
print(confint(LM)) # 95% confidence interval for effect size of AmE/BrE
plot(LM) # model diagnostics (residuals increase with relative frequency!)
dev.copy2pdf(file="img/AmBrE_LM_diagnostics.pdf", onefile=FALSE)
LM.predict <- data.frame(Predictors2, predicted.LM=predict(LM, newdata=Predictors2))
print(LM.predict) # compare observed mean frequencies and mean frequencies predicted by model
print(anova(lm(relative_frequency ~ corpus * name, data=PassBoth2))) # no evidence for interaction between register and language
response.matrix <- cbind(PassBoth2$passive, PassBoth2$n_s - PassBoth2$passive) # response matrix with "successes" and "failuers"
GLM2 <- glm(response.matrix ~ corpus * name, family=binomial, data=PassBoth2) # here, we get a significant interaction effect
print(anova(GLM2, test="Chisq")) # both AmE/BrE and the interaction are highly significant
print(summary(GLM2)) # no reliable estimate for AmE/BrE effect; the residual deviance (4884 on df=970) is not much better than
GLM2 <- glm(response.matrix ~ name + corpus : name, family=binomial, data=PassBoth2) # study AmE/BrE differences within each register
print(anova(GLM2, test="Chisq")) # overall, AmE/BrE is highly significant
print(summary(GLM2)) # significant effects in some registers, both positive and negative; residual deviance still high
GLM2.predict <- data.frame(LM2.predict, predicted.GLM2=100 * predict(GLM2, newdata=Predictors2, type="response"))
LM.pred
GLM2.predict <- data.frame(LM.predict, predicted.GLM2=100 * predict(GLM2, newdata=Predictors2, type="response"))#
print(GLM2.predict) # it is not obvious that GLM predictions are "better" than those of LM (but model is much more appropriate)
GLM <- glm(response.matrix ~ corpus * name, family=binomial, data=PassBoth2) # here, we get a significant interaction effect#
print(anova(GLM, test="Chisq")) # both AmE/BrE and interaction are highly significant#
print(summary(GLM)) # no reliable estimate for AmE/BrE effect; the residual deviance (4884 on df=970) is not much better than before#
## -- significant effects for registers with unusually large or small differences between AmE and BrE#
## -- negative interaction effects show registers that "go against the trend"#
#
GLM <- glm(response.matrix ~ name + corpus : name, family=binomial, data=PassBoth2) # study AmE/BrE differences within each register#
print(anova(GLM, test="Chisq")) # overall, AmE/BrE is highly significant#
print(summary(GLM)) # significant effects in some registers, both positive and negative; residual deviance still high#
#
GLM.predict <- data.frame(LM.predict, predicted.GLM=100 * predict(GLM2, newdata=Predictors2, type="response"))#
print(GLM.predict) # it is not obvious that GLM predictions are "better" than those of LM (but model is much more appropriate)
plot(GLM) # model diagnostics
GLM <- glm(response.matrix ~ corpus * name, family=binomial, data=PassBoth2) # here, we get a significant interaction effect#
print(anova(GLM, test="Chisq")) # both AmE/BrE and interaction are highly significant#
print(summary(GLM)) # no reliable estimate for AmE/BrE effect; the residual deviance (4884 on df=970) is not much better than before#
## -- significant effects for registers with unusually large or small differences between AmE and BrE#
## -- negative interaction effects show registers that "go against the trend"#
#
plot(GLM) # model diagnostics
GLM <- glm(response.matrix ~ name + corpus : name, family=binomial, data=PassBoth2) # study AmE/BrE differences within each register
plot(GLM) # model diagnostics look quite reassuring now
GLM <- glm(response.matrix ~ corpus * name, family=binomial, data=PassBoth2) # here, we get a significant interaction effect
plot(GLM) # model diagnostics look quite reassuring now
dev.copy2pdf(file="img/AmBrE_GLM_diagnostics.pdf", onefile=FALSE)
dev.off()
screen.device(width=12, height=8, bg="white")
par(cex=1.3, mar=c(1,4,2,1)+.5, oma=c(0,0,0,0), mfrow=c(2,1))
PassSorted2 <- PassBoth2[ order(PassBoth2$name, PassBoth2$corpus, PassBoth2$id), ]
dim(PassBoth2)
dim(PassSorted2)
head(PassSorted2)
show.predictors <- function (formula, data, show.formula=deparse(substitute(formula))) {#
  LM <- lm(formula, data=data)#
  x <- 1:nrow(data)#
  y <- data$relative_frequency#
  y.lm <- predict(LM)#
  plot.sym <- ifelse(data$corpus == "AmE", 3, 20)#
  plot(x, y, pch=plot.sym, cex=0.7, ylim=c(0,60), ylab="relative frequency (%)",#
       main=paste("Linear model predictions (", show.formula, ")", sep=""),#
       xaxs="i", yaxs="i", xaxt="n") # observed relative frequencies as points#
  breaks <- tapply(x, data$name, min)#
  abline(v=breaks, col="#666666") # indicate boundaries between sections of corpora#
  text(breaks+5, 59, adj=c(1,1), srt=90, labels=levels(data$name), col="#008800", cex=.8, font=2) # and show register names#
  line.col <- ifelse(data$corpus == "Brown", "red", "blue")#
  segments(x-.5, y.lm, x+.5, y.lm, col=line.col, lwd=3) # predicted relative frequencies as coloured lines#
  legend(992, 42, xjust=1, yjust=1, legend=c("Brown","LOB"), pch=c(3,20), col=c("red","blue"), lwd=3, bg="white")#
  R2 <- summary(LM)$r.squared # print some goodness-of-fit information#
  .tmp <- anova(LM)#
  SS.resid <- .tmp$"Sum Sq"[length(.tmp$"Sum Sq")]#
  print(data.frame(R2, SS.resid, row.names=show.formula))#
}
show.predictors <- function (formula, data, show.formula=deparse(substitute(formula))) {#
  LM <- lm(formula, data=data)#
  x <- 1:nrow(data)#
  y <- data$relative_frequency#
  y.lm <- predict(LM)#
  plot.sym <- ifelse(data$corpus == "AmE", 3, 20)#
  plot(x, y, pch=plot.sym, cex=0.7, ylim=c(0,60), ylab="relative frequency (%)",#
       main=paste("Linear model predictions (", show.formula, ")", sep=""),#
       xaxs="i", yaxs="i", xaxt="n") # observed relative frequencies as points#
  breaks <- tapply(x, data$name, min)#
  abline(v=breaks, col="#666666") # indicate boundaries between sections of corpora#
  text(breaks+5, 59, adj=c(1,1), srt=90, labels=levels(data$name), col="#008800", cex=.8, font=2) # and show register names#
  line.col <- ifelse(data$corpus == "AmE", "red", "blue")#
  segments(x-.5, y.lm, x+.5, y.lm, col=line.col, lwd=3) # predicted relative frequencies as coloured lines#
  legend(992, 42, xjust=1, yjust=1, legend=c("AmE","BrE"), pch=c(3,20), col=c("red","blue"), lwd=3, bg="white")#
  R2 <- summary(LM)$r.squared # print some goodness-of-fit information#
  .tmp <- anova(LM)#
  SS.resid <- .tmp$"Sum Sq"[length(.tmp$"Sum Sq")]#
  print(data.frame(R2, SS.resid, row.names=show.formula))#
}
show.residuals <- function (formula, data) {#
  LM <- lm(formula, data=data)#
  x <- 1:nrow(data)#
  y <- data$relative_frequency#
  y.lm <- predict(LM)#
  y.resid <- y - y.lm#
  plot.sym <- ifelse(data$corpus == "AmE", 3, 20)#
  plot(x, y.resid, pch=plot.sym, cex=0.7, ylim=c(-30,30), ylab="residuals (%)", main=paste("Unexplained residuals of linear model"),#
       xaxs="i", yaxs="i", xaxt="n") # residuals as points with "stems"#
  segments(x, y.resid, x, 0, lwd=.5, col="black")#
  breaks <- tapply(x, data$name, min)#
  abline(v=breaks, col="#666666") # indicate boundaries between sections of corpora#
  text(breaks+5, 29, adj=c(1,1), srt=90, labels=levels(data$name), col="#008800", cex=.8, font=2) # and show register names#
  abline(h=0, lwd=3, col="black") # zero line for residuals#
  legend(992, -28, xjust=1, yjust=0, legend=c("AmE","BrE"), pch=c(3,20), col="black", bg="white")#
}
show.predictors(relative_frequency ~ 1, PassSorted2, show.formula="p ~ 1")
show.residuals(relative_frequency ~ 1, PassSorted)
show.residuals(relative_frequency ~ 1, PassSorted2)
show.predictors(relative_frequency ~ 1, PassSorted2, show.formula="p ~ 1")#
show.residuals(relative_frequency ~ 1, PassSorted2)
show.predictors <- function (formula, data, show.formula=deparse(substitute(formula))) {#
  LM <- lm(formula, data=data)#
  x <- 1:nrow(data)#
  y <- data$relative_frequency#
  y.lm <- predict(LM)#
  plot.sym <- ifelse(data$corpus == "AmE", 3, 20)#
  plot(x, y, pch=plot.sym, cex=0.7, ylim=c(0,60), ylab="relative frequency (%)",#
       main=paste("Linear model predictions (", show.formula, ")", sep=""),#
       xaxs="i", yaxs="i", xaxt="n") # observed relative frequencies as points#
  breaks <- tapply(x, data$name, min)#
  abline(v=breaks, col="#666666") # indicate boundaries between sections of corpora#
  text(breaks+5, 59, adj=c(1,1), srt=90, labels=levels(data$name), col="#008800", cex=.9, font=2) # and show register names#
  line.col <- ifelse(data$corpus == "AmE", "red", "blue")#
  segments(x-.5, y.lm, x+.5, y.lm, col=line.col, lwd=3) # predicted relative frequencies as coloured lines#
  legend(992, 42, xjust=1, yjust=1, legend=c("AmE","BrE"), pch=c(3,20), col=c("red","blue"), lwd=3, bg="white")#
  R2 <- summary(LM)$r.squared # print some goodness-of-fit information#
  .tmp <- anova(LM)#
  SS.resid <- .tmp$"Sum Sq"[length(.tmp$"Sum Sq")]#
  print(data.frame(R2, SS.resid, row.names=show.formula))#
}#
#
show.residuals <- function (formula, data) {#
  LM <- lm(formula, data=data)#
  x <- 1:nrow(data)#
  y <- data$relative_frequency#
  y.lm <- predict(LM)#
  y.resid <- y - y.lm#
  plot.sym <- ifelse(data$corpus == "AmE", 3, 20)#
  plot(x, y.resid, pch=plot.sym, cex=0.7, ylim=c(-30,30), ylab="residuals (%)", main=paste("Unexplained residuals of linear model"),#
       xaxs="i", yaxs="i", xaxt="n") # residuals as points with "stems"#
  segments(x, y.resid, x, 0, lwd=.5, col="black")#
  breaks <- tapply(x, data$name, min)#
  abline(v=breaks, col="#666666") # indicate boundaries between sections of corpora#
  text(breaks+5, 29, adj=c(1,1), srt=90, labels=levels(data$name), col="#008800", cex=.9, font=2) # and show register names#
  abline(h=0, lwd=3, col="black") # zero line for residuals#
  legend(992, -28, xjust=1, yjust=0, legend=c("AmE","BrE"), pch=c(3,20), col="black", bg="white")#
}#
#
show.predictors(relative_frequency ~ 1, PassSorted2, show.formula="p ~ 1")#
show.residuals(relative_frequency ~ 1, PassSorted2)
show.predictors <- function (formula, data, show.formula=deparse(substitute(formula))) {#
  LM <- lm(formula, data=data)#
  x <- 1:nrow(data)#
  y <- data$relative_frequency#
  y.lm <- predict(LM)#
  plot.sym <- ifelse(data$corpus == "AmE", 3, 20)#
  plot(x, y, pch=plot.sym, cex=0.7, ylim=c(0,60), ylab="relative frequency (%)",#
       main=paste("Linear model predictions (", show.formula, ")", sep=""),#
       xaxs="i", yaxs="i", xaxt="n") # observed relative frequencies as points#
  breaks <- tapply(x, data$name, min)#
  abline(v=breaks, col="#666666") # indicate boundaries between sections of corpora#
  text(breaks+2, 59, adj=c(1,1), srt=90, labels=levels(data$name), col="#008800", cex=.9, font=2) # and show register names#
  line.col <- ifelse(data$corpus == "AmE", "red", "blue")#
  segments(x-.5, y.lm, x+.5, y.lm, col=line.col, lwd=3) # predicted relative frequencies as coloured lines#
  legend(992, 42, xjust=1, yjust=1, legend=c("AmE","BrE"), pch=c(3,20), col=c("red","blue"), lwd=3, bg="white")#
  R2 <- summary(LM)$r.squared # print some goodness-of-fit information#
  .tmp <- anova(LM)#
  SS.resid <- .tmp$"Sum Sq"[length(.tmp$"Sum Sq")]#
  print(data.frame(R2, SS.resid, row.names=show.formula))#
}#
#
show.residuals <- function (formula, data) {#
  LM <- lm(formula, data=data)#
  x <- 1:nrow(data)#
  y <- data$relative_frequency#
  y.lm <- predict(LM)#
  y.resid <- y - y.lm#
  plot.sym <- ifelse(data$corpus == "AmE", 3, 20)#
  plot(x, y.resid, pch=plot.sym, cex=0.7, ylim=c(-30,30), ylab="residuals (%)", main=paste("Unexplained residuals of linear model"),#
       xaxs="i", yaxs="i", xaxt="n") # residuals as points with "stems"#
  segments(x, y.resid, x, 0, lwd=.5, col="black")#
  breaks <- tapply(x, data$name, min)#
  abline(v=breaks, col="#666666") # indicate boundaries between sections of corpora#
  text(breaks+5, 29, adj=c(1,1), srt=90, labels=levels(data$name), col="#008800", cex=.9, font=2) # and show register names#
  abline(h=0, lwd=3, col="black") # zero line for residuals#
  legend(992, -28, xjust=1, yjust=0, legend=c("AmE","BrE"), pch=c(3,20), col="black", bg="white")#
}#
#
show.predictors(relative_frequency ~ 1, PassSorted2, show.formula="p ~ 1")#
show.residuals(relative_frequency ~ 1, PassSorted2)
show.predictors <- function (formula, data, show.formula=deparse(substitute(formula))) {#
  LM <- lm(formula, data=data)#
  x <- 1:nrow(data)#
  y <- data$relative_frequency#
  y.lm <- predict(LM)#
  plot.sym <- ifelse(data$corpus == "AmE", 3, 20)#
  plot(x, y, pch=plot.sym, cex=0.7, ylim=c(0,60), ylab="relative frequency (%)",#
       main=paste("Linear model predictions (", show.formula, ")", sep=""),#
       xaxs="i", yaxs="i", xaxt="n") # observed relative frequencies as points#
  breaks <- tapply(x, data$name, min)#
  abline(v=breaks, col="#666666") # indicate boundaries between sections of corpora#
  text(breaks+3, 59, adj=c(1,1), srt=90, labels=levels(data$name), col="#008800", cex=.9, font=2) # and show register names#
  line.col <- ifelse(data$corpus == "AmE", "red", "blue")#
  segments(x-.5, y.lm, x+.5, y.lm, col=line.col, lwd=3) # predicted relative frequencies as coloured lines#
  legend(992, 42, xjust=1, yjust=1, legend=c("AmE","BrE"), pch=c(3,20), col=c("red","blue"), lwd=3, bg="white")#
  R2 <- summary(LM)$r.squared # print some goodness-of-fit information#
  .tmp <- anova(LM)#
  SS.resid <- .tmp$"Sum Sq"[length(.tmp$"Sum Sq")]#
  print(data.frame(R2, SS.resid, row.names=show.formula))#
}#
#
show.residuals <- function (formula, data) {#
  LM <- lm(formula, data=data)#
  x <- 1:nrow(data)#
  y <- data$relative_frequency#
  y.lm <- predict(LM)#
  y.resid <- y - y.lm#
  plot.sym <- ifelse(data$corpus == "AmE", 3, 20)#
  plot(x, y.resid, pch=plot.sym, cex=0.7, ylim=c(-30,30), ylab="residuals (%)", main=paste("Unexplained residuals of linear model"),#
       xaxs="i", yaxs="i", xaxt="n") # residuals as points with "stems"#
  segments(x, y.resid, x, 0, lwd=.5, col="black")#
  breaks <- tapply(x, data$name, min)#
  abline(v=breaks, col="#666666") # indicate boundaries between sections of corpora#
  text(breaks+3, 29, adj=c(1,1), srt=90, labels=levels(data$name), col="#008800", cex=.9, font=2) # and show register names#
  abline(h=0, lwd=3, col="black") # zero line for residuals#
  legend(992, -28, xjust=1, yjust=0, legend=c("AmE","BrE"), pch=c(3,20), col="black", bg="white")#
}#
#
show.predictors(relative_frequency ~ 1, PassSorted2, show.formula="p ~ 1")#
show.residuals(relative_frequency ~ 1, PassSorted2)
dev.copy2pdf(file="img/AmBrE_LM_visual_1.pdf", onefile=FALSE)
show.predictors(relative_frequency ~ 1 + name, PassSorted2, show.formula="p ~ 1 + genre")#
show.residuals(relative_frequency ~ 1 + name, PassSorted2)
dev.copy2pdf(file="img/AmBrE_LM_visual_2.pdf", onefile=FALSE)
show.predictors(relative_frequency ~ 1 + name + corpus, PassSorted2, show.formula="p ~ 1 + genre + AmBr")#
show.residuals(relative_frequency ~ 1 + name + corpus, PassSorted2)#
dev.copy2pdf(file="img/AmBrE_LM_visual_3.pdf", onefile=FALSE)
show.predictors(relative_frequency ~ 1 + name + corpus, PassSorted2, show.formula="p ~ 1 + genre + Am/Br")#
show.residuals(relative_frequency ~ 1 + name + corpus, PassSorted2)#
dev.copy2pdf(file="img/AmBrE_LM_visual_3.pdf", onefile=FALSE)
dev.off()
select.cats <- c("A", "B", "E", "H", "J", "K", "M", "N", "P")#
Brown2 <- subset(PassBrown, cat %in% select.cats)#
LOB2 <- subset(PassLOB, cat %in% select.cats)#
size2.brown <- nrow(Brown2)  # sample sizes are different now#
size2.lob <- nrow(LOB2)#
print(c(Brown=size2.brown, LOB=size2.lob)) # 310 vs. 312
p2.brown <- sum(Brown2$passive) / sum(Brown2$n_s)#
p2.lob <- sum(LOB2$passive) / sum(LOB2$n_s)#
print(round(100 * data.frame("AmE"=p2.brown, "BrE"=p2.lob, row.names="passives (%)"), 2))
select.cats
n2.brown <- sum(Brown2$n_s)#
n2.lob <- sum(LOB2$n_s)#
k2.brown <- sum(Brown2$passive)#
k2.lob <- sum(LOB2$passive)#
p2.brown <- k2.brown / n2.brown#
p2.lob <- k2.lob / n2.lob#
print(data.frame(passives=c(k2.brown,k2.lob), sample_size=c(n2.brown,n2.lob), percentage=round(100 * c(p2.brown,p2.lob),1), row.names=c("AmE", "BrE")))
cont.table <- cbind(c(k2.lob, n2.lob-k2.lob), c(k2.brown, n2.brown-k2.brown))
cont.table <- cbind(c(k2.lob, n2.lob-k2.lob), c(k2.brown, n2.brown-k2.brown))#
print(cont.table)
?cbind
cont.table <- cbind(c(k2.lob, n2.lob-k2.lob), c(k2.brown, n2.brown-k2.brown))#
colnames(cont.table) <- c("BrE", "AmE")#
rownames(cont.table) <- c("passive", "active")#
print(cont.table)
print(prop.test(c(k2.lob, k2.brown), c(n2.lob, n2.brown)))#
print(chisq.test(cont.table))#
print(fisher.test(cont.table))
print(t.test(LOB2$passive/LOB2$n_s, Brown2$passive/Brown2$n_s))
brown.names <- c("press reportage", "press editorial", "press reviews", "religion", "skills / hobbies", "popular lore", "belles lettres", "miscellaneous", "learned", "general fiction", "detective", "science fiction", "adventure", "romance", "humour")#
brown.cats <- data.frame(cat=c("A", "B", "C", "D", "E", "F", "G", "H", "J", "K", "L", "M", "N", "P", "R"),#
                         name=factor(brown.names, levels=brown.names)) # make sure that factor levels for names are in correct order#
                         #
PassBrown$corpus <- "Brown"             # merge Brown and LOB data for conditioning plot#
PassLOB$corpus <- "LOB"#
PassBoth <- rbind(PassBrown, PassLOB)#
PassBoth <- transform(PassBoth, corpus=factor(corpus), relative_frequency=100*passive/n_s)#
PassBoth <- merge(PassBoth, brown.cats, by="cat")
brown2.names <- as.character(subset(brown.cats, cat %in% select.cats)$name)#
brown2.cats <- data.frame(cat=select.cats, name=factor(brown2.names, levels=brown2.names))#
Brown2$corpus <- "AmE"#
LOB2$corpus <- "BrE"#
PassBoth2 <- rbind(Brown2, LOB2)#
PassBoth2 <- transform(PassBoth2, corpus=factor(corpus), relative_frequency=100*passive/n_s)#
PassBoth2 <- merge(PassBoth2, brown2.cats, by="cat")
PassBoth2[sample(1:nrow(PassBoth2), 20),]
print(brown2.cats)
bwplot(relative_frequency ~ corpus | name, aspect=4, box.ratio=2, pch="|", data=PassBoth2, ylim=c(0,100), ylab="relative frequency of passives (%)", panel=my.panel, par.settings=my.pars)
signif.code <- function (p) {#
  ifelse(p < .01, ifelse(p < .001, "***", "**"), ifelse(p < .05, "*", ifelse(p < .1, "?", "")))#
}#
test.genre <- function (cat, data=PassBoth, catinfo=brown.cats) {#
  .cat <- as.character(cat)  # so we can use local variable in subset() below#
  ## NB: as.character() avoids problems with different sets of levels if arg <cat> is part of factor#
  cat.name <- as.character(catinfo$name[catinfo$cat == .cat])#
  data.Brown <- subset(data, cat == .cat & corpus == "AmE")#
  data.LOB <- subset(data, cat == .cat & corpus == "BrE")#
  k.Brown <- sum(data.Brown$passive)  # pooled data (k = passives, n = sample size)#
  n.Brown <- sum(data.Brown$n_s)#
  k.LOB <- sum(data.LOB$passive)#
  n.LOB <- sum(data.LOB$n_s)#
  p.Brown <- k.Brown / n.Brown # MLE for respective population proportion#
  p.LOB <- k.LOB / n.LOB#
  E.sd.Brown <- sqrt(100 * p.Brown * (1 - p.Brown)) # expected s.d. (assuming 100 sentences per sample)#
  E.sd.LOB <- sqrt(100 * p.LOB * (1 - p.LOB))#
  O.sd.Brown <- sd(data.Brown$passive)  # observed s.d.#
  O.sd.LOB <- sd(data.LOB$passive)#
  randomness.Brown <- ks.test(jitter(data.Brown$passive), "pnorm", mean=mean(data.Brown$passive), sd=E.sd.Brown)$p.value#
  randomness.LOB <- ks.test(jitter(data.LOB$passive), "pnorm", mean=mean(data.LOB$passive), sd=E.sd.LOB)$p.value#
  .res <- prop.test(c(k.LOB, k.Brown), c(n.LOB, n.Brown)) # chi-squared test on pooled data#
  X2 <- .res$statistic#
  chisq.p <- .res$p.value#
  .res <- t.test( data.LOB$passive / data.LOB$n_s, data.Brown$passive / data.Brown$n_s) # t-test on individual texts#
  t <- .res$statistic#
  t.p <- .res$p.value#
  data.frame(p.Brown, p.LOB, E.sd.Brown, O.sd.Brown, KS1=signif.code(randomness.Brown), E.sd.LOB, O.sd.LOB, KS2=signif.code(randomness.LOB), X2, ChiSq=chisq.p, Sig1=signif.code(chisq.p), t, t.Test=t.p, Sig2=signif.code(t.p), row.names=cat.name)#
}#
#
all.genres2 <- do.call(rbind, lapply(brown2.cats$cat, test.genre, data=PassBoth2, catinfo=brown2.cats))#
all.genres2[, 1:2] <- round(all.genres2[, 1:2], 4)  # round different columns appropriately#
all.genres2[, c(3,4,6,7)] <- round(all.genres2[, c(3,4,6,7)], 2)#
all.genres2[, c(9,12)] <- round(all.genres2[, c(9,12)], 2)#
all.genres2[, c(10,13)] <- signif(all.genres2[, c(10,13)], 3)#
print(all.genres2)
Predictors2 <- aggregate(data.frame(observed_mean=PassBoth2$relative_frequency), list(corpus=PassBoth2$corpus, name=PassBoth2$name), mean)#
#
## linear models are really inappropriate, but give a nice illustration of the basic approach#
LM <- lm(relative_frequency ~ corpus + name, data=PassBoth2)
print(anova(LM))  # AmE/BrE has (weakly) significant effect once register variation is taken into account
print(summary(LM)) # effect size and effects of individual registers (model estimates)
print(confint(LM)) # 95% confidence interval for effect size of AmE/BrE
LM.predict <- data.frame(Predictors2, predicted.LM=predict(LM, newdata=Predictors2))#
print(LM.predict) # compare observed mean frequencies and mean frequencies predicted by model
print(anova(lm(relative_frequency ~ corpus * name, data=PassBoth2))) # no evidence for interaction between register and language
response.matrix <- cbind(PassBoth2$passive, PassBoth2$n_s - PassBoth2$passive) # response matrix with "successes" and "failuers"#
#
GLM <- glm(response.matrix ~ corpus * name, family=binomial, data=PassBoth2) # here, we get a significant interaction effect#
print(anova(GLM, test="Chisq")) # both AmE/BrE and interaction are highly significant#
print(summary(GLM)) # no reliable estimate for AmE/BrE effect; the residual deviance (4884 on df=970) is not much better than
GLM <- glm(response.matrix ~ name + corpus : name, family=binomial, data=PassBoth2) # study AmE/BrE differences within each register#
print(anova(GLM, test="Chisq")) # overall, AmE/BrE is highly significant#
print(summary(GLM)) # significant effects in some registers, both positive and negative; residual deviance still high
GLM.predict <- data.frame(LM.predict, predicted.GLM=100 * predict(GLM2, newdata=Predictors2, type="response"))#
print(GLM.predict) # it is not obvious that GLM predictions are "better" than those of LM (but model is much more appropriate)
library(corpora)
cont.table
?cont.tabl
?cont.table
cont.table(30,150, 25,100)
fisher.test(cont.table(30,150, 25,100))
fisher.test(cont.table(60,300, 52,200))
fisher.test(cont.table(60,400, 52,200))
fisher.test(cont.table(70,400, 52,200))
fisher.test(cont.table(60,200, 52,200))
fisher.test(cont.table(60,220, 52,200))
60/220
fisher.test(cont.table(60,320, 52,200))
60/320
62/320
61/320
61/330
60/330
60/320
.18*320
.19*320
.17*320
18*5
18*15
18*17
18*18
18*19
18*16
18*15
15/270
50/270
48/270
52/270
51/270
60 / .18
60 / .19
60 / .20
60 / .18
60/333
fisher.test(cont.table(60,333, 52,200))
333 * .19
340 * .19
fisher.test(cont.table(60,333, 54,200))
fisher.test(cont.table(60,333, 50,200))
fisher.test(cont.table(60,333, 48,200))
fisher.test(cont.table(60,333, 50,200))
prop.test(c(60,50), c(333,200))
prop.test(c(60,50), c(300,200))
60/300
300 * .19
300 * .18
prop.test(c(54,50), c(300,200))
cont.table(54,300,50,200)
rownames(cont.table) <- c("passive", "active")
cont.table
example <- cont.table(54,300,50,200)
rownames(example) <- c("passive", "active")
example
colnames(example) <- c("AmE", "BrE")
example
chisq.test(example)
fisher.test(example)
binom.test(60000,1000000)
binom.test(60000,1000000, p=.06)
binom.test(60000,1000000, p=.061)
binom.test(60000,1000000, p=.0601)
binom.test(60000,1000000, p=.0605)
screen.device(width=11, height=6, bg="white")#
par(cex=1.3, mar=c(4,4,1,0)+.5, xaxs="i", yaxs="i");
n <- 100#
k <- 0:60 # this range includes all data points from Brown and LOB
head(Brown2)
head(LOB2)
dim(LOB2)
sum(LOB2$n_s)
sum(LOB2$n_w)
sum(Brown2$n_s)
sum(Brown2$n_w)
screen.device(width=12, height=8, bg="white")#
par(cex=1.3, mar=c(1,4,2,1)+.5, oma=c(0,0,0,0), mfrow=c(2,1))#
#
PassSorted2 <- PassBoth2[ order(PassBoth2$name, PassBoth2$corpus, PassBoth2$id), ]#
#
show.predictors <- function (formula, data, show.formula=deparse(substitute(formula))) {#
  LM <- lm(formula, data=data)#
  x <- 1:nrow(data)#
  y <- data$relative_frequency#
  y.lm <- predict(LM)#
  plot.sym <- ifelse(data$corpus == "AmE", 3, 20)#
  plot(x, y, pch=plot.sym, cex=0.7, ylim=c(0,60), ylab="relative frequency (%)",#
       main=paste("Linear model predictions (", show.formula, ")", sep=""),#
       xaxs="i", yaxs="i", xaxt="n") # observed relative frequencies as points#
  breaks <- tapply(x, data$name, min)#
  abline(v=breaks, col="#666666") # indicate boundaries between sections of corpora#
  text(breaks+3, 59, adj=c(1,1), srt=90, labels=levels(data$name), col="#008800", cex=.9, font=2) # and show register names#
  line.col <- ifelse(data$corpus == "AmE", "red", "blue")#
  segments(x-.5, y.lm, x+.5, y.lm, col=line.col, lwd=3) # predicted relative frequencies as coloured lines#
  legend(992, 42, xjust=1, yjust=1, legend=c("AmE","BrE"), pch=c(3,20), col=c("red","blue"), lwd=3, bg="white")#
  R2 <- summary(LM)$r.squared # print some goodness-of-fit information#
  .tmp <- anova(LM)#
  SS.resid <- .tmp$"Sum Sq"[length(.tmp$"Sum Sq")]#
  print(data.frame(R2, SS.resid, row.names=show.formula))#
}#
#
show.residuals <- function (formula, data) {#
  LM <- lm(formula, data=data)#
  x <- 1:nrow(data)#
  y <- data$relative_frequency#
  y.lm <- predict(LM)#
  y.resid <- y - y.lm#
  plot.sym <- ifelse(data$corpus == "AmE", 3, 20)#
  plot(x, y.resid, pch=plot.sym, cex=0.7, ylim=c(-30,30), ylab="residuals (%)", main=paste("Unexplained residuals of linear model"),#
       xaxs="i", yaxs="i", xaxt="n") # residuals as points with "stems"#
  segments(x, y.resid, x, 0, lwd=.5, col="black")#
  breaks <- tapply(x, data$name, min)#
  abline(v=breaks, col="#666666") # indicate boundaries between sections of corpora#
  text(breaks+3, 29, adj=c(1,1), srt=90, labels=levels(data$name), col="#008800", cex=.9, font=2) # and show register names#
  abline(h=0, lwd=3, col="black") # zero line for residuals#
  legend(992, -28, xjust=1, yjust=0, legend=c("AmE","BrE"), pch=c(3,20), col="black", bg="white")#
}
show.predictors(relative_frequency ~ 1, PassSorted2, show.formula="p ~ 1")#
show.residuals(relative_frequency ~ 1, PassSorted2)
show.predictors(relative_frequency ~ 1 + name, PassSorted2, show.formula="p ~ 1 + genre")#
show.residuals(relative_frequency ~ 1 + name, PassSorted2)
show.predictors(relative_frequency ~ 1 + name + corpus, PassSorted2, show.formula="p ~ 1 + genre + Am/Br")#
show.residuals(relative_frequency ~ 1 + name + corpus, PassSorted2)
## get possible value combinations of predictor variables and observed mean relative frequencies#
Predictors2 <- aggregate(data.frame(observed_mean=PassBoth2$relative_frequency), list(corpus=PassBoth2$corpus, name=PassBoth2$name), mean)#
#
## linear models are really inappropriate, but give a nice illustration of the basic approach#
LM <- lm(relative_frequency ~ corpus + name, data=PassBoth2)#
print(anova(LM))  # AmE/BrE has (weakly) significant effect once register variation is taken into account
str(anova(LM))
sum(anova(LM)$"Sum Sq")
var(PassBoth2$relative_frequency)
var(PassBoth2$relative_frequency)*nrwo(PassBoth2)
var(PassBoth2$relative_frequency)*nrow(PassBoth2)
sum((PassBoth2$relative_frequency - mean(PassBoth2$relative_frequency))^2)
anova(LM)$"Sum Sq" /sum(anova(LM)$"Sum Sq")
anova(LM)$"Sum Sq"
head(PassBoth)
head(PassBoth2)
binom.p <- PassBoth2$relative_frequency # assume each text is sampled from population with its MLE proportion#
binom.n <- PassBoth2$n_s
binom.var <- binom.n * binom.p * (1 - binom.p) # variance of sampling distribution for each text
binom.var <- binom.n * binom.p * (1 - binom.p) # variance of sampling distribution for each text#
print(sum(binom.var))
binom.p <- PassBoth2$relative_frequency / 100 # assume each text is sampled from population with its MLE proportion#
binom.n <- PassBoth2$n_s#
binom.var <- binom.n * binom.p * (1 - binom.p) # variance of sampling distribution for each text
print(sum(binom.var))
binom.p <- PassBoth$relative_frequency / 100 # assume each text is sampled from population with its MLE proportion#
binom.n <- PassBoth$n_s#
binom.var <- binom.n * binom.p * (1 - binom.p) # variance of sampling distribution for each text
print(sum(binom.var))
dim(PassBoth)
length(binom.var)
binom.p <- PassBoth$relative_frequency / 100 # assume each text is sampled from population with its MLE proportion#
binom.n <- PassBoth$n_s#
binom.var <- binom.n * binom.p * (1 - binom.p) # variance of sampling distribution for each text#
print(sum(binom.var))
binom.n <- 100#
binom.var <- binom.n * binom.p * (1 - binom.p) # variance of sampling distribution for each text#
print(sum(binom.var))
binom.p <- PassBoth2$relative_frequency / 100 # assume each text is sampled from population with its MLE proportion#
binom.n <- 100 # assume #
binom.var <- binom.n * binom.p * (1 - binom.p) # variance of sampling distribution for each text#
print(sum(binom.var))
binom.p <- PassBoth$relative_frequency / 100 # assume each text is sampled from population with its MLE proportion#
binom.n <- 100 # assume each text is a sample of n = 100 sentences#
binom.var <- binom.n * binom.p * (1 - binom.p) # variance of sampling distribution for each text#
print(sum(binom.var))
binom.p <- PassBoth2$relative_frequency / 100 # assume each text is sampled from population with its MLE proportion#
binom.n <- 100 # assume each text is a sample of n = 100 sentences#
binom.var <- binom.n * binom.p * (1 - binom.p) # variance of sampling distribution for each text#
print(sum(binom.var))
sum(binom.var) / 189861
MetaBrown <- read.delim("meta/brown_meta.tbl")#
MetaLOB <- read.delim("meta/lob_meta.tbl")#
#
PassBrown <- read.delim("tbl/passives.brown.tbl")#
PassLOB <- read.delim("tbl/passives.lob.tbl")
PassBrown <- merge(PassBrown, MetaBrown, by="id")#
PassLOB <- merge(PassLOB, MetaLOB, by="id")#
stopifnot(nrow(PassBrown) == 500 && nrow(PassLOB) == 500) # check that IDs have matched properly
head(PassBrown)
head(PassLob)
head(PassLOB)
rowsum(PassBrown[,c("passive","n_w","n_s")], PassBrown$cat)
?rowsum
rowsum(PassBrown[,c("passive","n_w","n_s")], PassBrown$cat)
Brown
Brown <- rowsum(PassBrown[,c("passive","n_w","n_s")], PassBrown$cat)
Brown
LOB <- rowsum(PassLOB[,c("passive","n_w","n_s")], PassLOB$cat)
LOB
brown.names <- c("press reportage", "press editorial", "press reviews", "religion", "skills / hobbies", "popular lore", "belles lettres", "miscellaneous", "learned", "general fiction", "detective", "science fiction", "adventure", "romance", "humour")#
brown.cats <- data.frame(cat=c("A", "B", "C", "D", "E", "F", "G", "H", "J", "K", "L", "M", "N", "P", "R"),#
                         name=factor(brown.names, levels=brown.names))
brown.cats
all(rownames(Brown) == brown.cats$cat)
all(rownames(OB) == brown.cats$cat)
all(rownames(LOB) == brown.cats$cat)
Brown$cat <- brown.cats$name
Brown
LOB$cat <- brown.cats$name
cbind(Brown, LOB)
prop.test(c(1034,1005), c(4387,4066))
Brown
LOB
setwd("/Users/severt/Writings/Courses/SIGIL/data")
dir()
write.csv(Brown, "passives.brown.csv", row.names=TRUE)
write.csv(LOB, "passives.lob.csv", row.names=TRUE)
x1 <- read.csv("passives.brown.csv")
x2 <- read.csv("passives.lob.csv")
all.equal(Brown, x1)
x1
x1 <- read.csv("passives.brown.csv", row.names=TRUE)
args(read.table)
x1 <- read.csv("passives.brown.csv", row.names=TRUE)
x1 <- read.csv("passives.brown.csv")
x1
x2 <- read.csv("passives.lob.csv")
x2
Brown
LOB
x2
all.equal(LOB, x2[,-1])
all.equal(Brown, x1[,-1])
